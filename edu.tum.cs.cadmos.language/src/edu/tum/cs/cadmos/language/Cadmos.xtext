grammar edu.tum.cs.cadmos.language.Cadmos with org.eclipse.xtext.common.Terminals

generate cadmos "http://www.tum.edu/cs/cadmos/language/Cadmos"

/* MODEL ELEMENTS */
Model:
	('package' name=QualifiedName)?
	imports+=Import*
	elements+=ModelElement*;

Import:
	'import' importedNamespace=QualifiedNameWithWildcard;

ModelElement:
	Component;

Component:
	'component' name=ID
	('(' (parameters+=Parameter (',' parameters+=Parameter)*)? ')')?
	'{' (elements+=ComponentElement)* '}';

Parameter:
	name=ID '=' value=INT;

ComponentElement:
	NamedComponentElement | Channel | Case;

NamedComponentElement:
	Port | Embedding | Variable;

enum PortDirection:
	Inbound='in' | Outbound='out';

Port:
	direction=PortDirection name=ID ('[' cardinality=Value ']')?;

Embedding:
	'embed' component=[Component]
	('(' (parameterAssignments+=ParameterAssignment (',' parameterAssignments+=ParameterAssignment)*)? ')')?
	name=ID ('[' cardinality=Value ']')?;

Channel:
	'channel' source=PortRef '->' destination=PortRef;

PortRef:
	(embedding=[Embedding] ('[' embeddingIndex=ID ']')? '.')? port=[Port] ('[' portIndex=ID ']')?;

Value:
	IntegerLiteral | ParameterRef;

ParameterRef:
	parameter=[Parameter];

ParameterAssignment:
	left=[Parameter] '=' right=Value;

Variable:
	'var' typeRef=TypeRef name=ID ('=' initializer=Expression)?;

Case:
	'case' guard=Expression '{' (subcases+=Case | actions+=Expression)* '}';

/* EXPRESSIONS */
Expression returns Expression:
	Assignment;

Assignment returns Expression:
	OrExpression (=> ({BinaryExpression.left=current} op='=') right=OrExpression)*;

OrExpression returns Expression:
	AndExpression (=> ({BinaryExpression.left=current} op='||') right=AndExpression)*;

AndExpression returns Expression:
	EqualityExpression (=> ({BinaryExpression.left=current} op='&&') right=EqualityExpression)*;

EqualityExpression returns Expression:
	RelationalExpression (=> ({BinaryExpression.left=current} op=('==' | '!=')) right=RelationalExpression)*;

RelationalExpression returns Expression:
	AdditiveExpression (=> ({BinaryExpression.left=current} op=('>=' | '<=' | '>' | '<')) right=AdditiveExpression)*;

AdditiveExpression returns Expression:
	MultiplicativeExpression (=> ({BinaryExpression.left=current} op=('+' | '-')) right=MultiplicativeExpression)*;

MultiplicativeExpression returns Expression:
	UnaryExpression (=> ({BinaryExpression.left=current} op=('*' | '**' | '/' | '%')) right=UnaryExpression)*;

UnaryExpression returns Expression:
	{UnaryExpression} op=('!' | '+' | '-') operand=PrimaryExpression
	| PrimaryExpression;

PrimaryExpression returns Expression:
	Call
	| ParenthesizedExpression
	| Literal;

Call returns Expression:
	Segment (=> ({BinaryExpression.left=current} op='.') right=Segment)*;

Segment returns Expression:
	CallableSegment
	//	| MemberSegment
	| ClosureSegment;

Callable:
	Port | Variable | ClosureParameter | Parameter;

CallableSegment returns Expression:
	{CallableSegment} callable=[Callable] ('[' index=Expression ']')?;

	// MemberSegment returns Expression:
// 	{MemberSegment} member=[Member];
enum ClosureOperators:
	For='for' | Exists='exists' | All='all';

ClosureSegment returns Expression:
	{ClosureSegment} operator=ClosureOperators
	'(' (parameters+=ClosureParameter (',' parameters+=ClosureParameter)* '|')? expression=Expression ')';

ClosureParameter:
	declaredName=ID;

ParenthesizedExpression returns Expression:
	'(' Expression ')';

Literal returns Expression:
	BooleanLiteral | IntegerLiteral | RealLiteral;

BooleanLiteral returns Expression:
	{BooleanLiteral} ('false' | isTrue?='true');

IntegerLiteral returns Expression:
	{IntegerLiteral} value=INT;

RealLiteral returns Expression:
	{RealLiteral} value=REAL;

/* TYPE SYSTEM */
TypeRef:
	PrimitiveTypeRef;

PrimitiveTypeRef:
	type=PrimitiveTypes;

enum PrimitiveTypes:
	Boolean | Integer | Real;

/* TERMINALS AND NAMES */
QualifiedName:
	ID ('.' ID)*;

QualifiedNameWithWildcard:
	QualifiedName '.*'?;

terminal REAL:
	('0'..'9')* '.' ('0'..'9')+ (('e' | 'E') ('+' | '-')? ('0'..'9')+)?;
