grammar edu.tum.cs.cadmos.language.Cadmos with org.eclipse.xtext.common.Terminals

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
generate cadmos "http://www.tum.edu/cs/cadmos/language/Cadmos"

/* MODEL ELEMENTS */
Model:
	('package' name=QualifiedName)?
	imports+=Import*
	elements+=ModelElement*;

Import:
	'import' importedNamespace=QualifiedNameWithWildcard;

ModelElement:
	Component | EnumDecl;

Component:
	'component' name=ID
	('(' (parameters+=Parameter (',' parameters+=Parameter)*)? ')')?
	'{' (elements+=ComponentElement)* '}';

Parameter:
	name=ID '=' value=INT;

ComponentElement:
	Port
	| Embedding
	| Variable
	| Channel
	| Case;

EnumDecl:
	'enum' name=ID '{' elements+=EnumElement (',' elements+=EnumElement)* '}';

EnumElement:
	name=ID;

enum PortDirection:
	Inbound='in'
	| Outbound='out';

Port:
	direction=PortDirection name=ID ('[' cardinality=Value ']')? (':' typeRef=TypeRef)? ('rate' rate=Value)?;

Embedding:
	'embed' name=ID ('[' cardinality=Value ']')? ':'
	component=[Component] ('(' (parameterValues+=Value (',' parameterValues+=Value)*)? ')')?;

Channel:
	'channel' (channelVariables+=ChannelVariable (',' channelVariables+=ChannelVariable)* '|')?
	source=PortRef '->' destination=PortRef;

ChannelVariable:
	name=ID '=' fromIndex=Expression (=> '..' toIndex=Expression);

PortRef:
	(embedding=[Embedding] ('[' embeddingIndex=ID ']')? '.')? port=[Port] ('[' portIndex=ID ']')?;

Value:
	IntegerLiteral | ParameterRef;

ParameterRef:
	parameter=[Parameter];

Variable:
	'var' name=ID (':' typeRef=TypeRef)? ('=' initializer=Expression)?;

Case:
	(('case' guard=Expression) | isDefault?='default') '{' (subcases+=Case | actions+=Expression)* '}';

/* EXPRESSIONS */
Expression returns Expression:
	Assignment;

Assignment returns Expression:
	OrExpression (=> ({BinaryExpression.left=current} op='=') right=OrExpression)*;

OrExpression returns Expression:
	AndExpression (=> ({BinaryExpression.left=current} op='||') right=AndExpression)*;

AndExpression returns Expression:
	EqualityExpression (=> ({BinaryExpression.left=current} op='&&') right=EqualityExpression)*;

EqualityExpression returns Expression:
	RelationalExpression (=> ({BinaryExpression.left=current} op=('==' | '!=')) right=RelationalExpression)*;

RelationalExpression returns Expression:
	AdditiveExpression (=> ({BinaryExpression.left=current} op=('>=' | '<=' | '>' | '<')) right=AdditiveExpression)*;

AdditiveExpression returns Expression:
	MultiplicativeExpression (=> ({BinaryExpression.left=current} op=('+' | '-')) right=MultiplicativeExpression)*;

MultiplicativeExpression returns Expression:
	UnaryExpression (=> ({BinaryExpression.left=current} op=('*' | '**' | '/' | '%')) right=UnaryExpression)*;

UnaryExpression returns Expression:
	{UnaryExpression} op=('!' | '+' | '-') operand=PrimaryExpression | PrimaryExpression;

PrimaryExpression returns Expression:
	Call | ParenthesizedExpression | Literal;

Call returns Expression:
	LocalCall | EnumElementCall;

Local:
	Parameter | Port | Variable | ClosureParameter;

LocalCall returns Expression:
	{LocalCall} local=[Local]
	('.' member=NativeFunctions
	'(' (closureParameters+=ClosureParameter (',' closureParameters+=ClosureParameter)* '|')?
	(parameterValues+=Expression (',' parameterValues+=Expression)*)? ')')?;

EnumElementCall returns Expression:
	{EnumElementCall} enumDecl=[EnumDecl] '.' element=[EnumElement];

enum NativeFunctions:
	ForEach='forEach' | Exists='exists' | All='all' | Select='select' | Collect='collect' | TimedAccess='at';

ClosureParameter:
	name=ID;

ParenthesizedExpression returns Expression:
	'(' Expression ')';

Literal returns Expression:
	BooleanLiteral | IntegerLiteral | RealLiteral;

BooleanLiteral returns Expression:
	{BooleanLiteral} ('false' | isTrue?='true');

IntegerLiteral returns Expression:
	{IntegerLiteral} value=INT;

RealLiteral returns Expression:
	{RealLiteral} value=REAL;

/* TYPE SYSTEM */
TypeRef:
	PrimitiveTypeRef | EnumTypeRef;

PrimitiveTypeRef:
	type=PrimitiveTypes;

enum PrimitiveTypes:
	Boolean='boolean'
	| Integer='int'
	| Real='real';

EnumTypeRef:
	type=[EnumDecl];

/* TERMINALS AND NAMES */
QualifiedName:
	ID ('.' ID)*;

QualifiedNameWithWildcard:
	QualifiedName '.*'?;

terminal REAL:
	('0'..'9')* '.' ('0'..'9')+ (('e' | 'E') ('+' | '-')? ('0'..'9')+)?;
