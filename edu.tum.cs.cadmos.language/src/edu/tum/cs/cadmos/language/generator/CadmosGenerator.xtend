/*
 * generated by Xtext
 */
package edu.tum.cs.cadmos.language.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IGenerator
import org.eclipse.xtext.generator.IFileSystemAccess
import edu.tum.cs.cadmos.language.cadmos.Component
import com.google.inject.Inject
import org.eclipse.xtext.naming.IQualifiedNameProvider
import edu.tum.cs.cadmos.language.cadmos.Model
import org.eclipse.xtext.EcoreUtil2
import edu.tum.cs.cadmos.language.cadmos.ComponentElement
import edu.tum.cs.cadmos.language.cadmos.Port
import edu.tum.cs.cadmos.language.cadmos.Callable
import edu.tum.cs.cadmos.language.cadmos.PrimitiveTypeRef
import edu.tum.cs.cadmos.language.cadmos.PrimitiveTypes
import edu.tum.cs.cadmos.language.cadmos.TypeRef
import java.awt.CardLayout$Card
import org.eclipse.emf.ecore.EPackage
import org.eclipse.emf.ecore.EcorePackage
import org.eclipse.emf.ecore.impl.EPackageImpl
import org.eclipse.emf.common.util.EList
import edu.tum.cs.cadmos.language.cadmos.Parameter
import edu.tum.cs.cadmos.language.cadmos.Embedding
import edu.tum.cs.cadmos.language.cadmos.Value
import edu.tum.cs.cadmos.language.cadmos.IntegerLiteral
import edu.tum.cs.cadmos.language.cadmos.IntegerLiteral
import edu.tum.cs.cadmos.language.cadmos.ParameterRef

class CadmosGenerator implements IGenerator {
	
	@Inject extension IQualifiedNameProvider
	
	override void doGenerate(Resource resource, IFileSystemAccess fsa) {
		generatePortClass(fsa);
		for(c: resource.allContents.toIterable.filter(typeof(Component))) {
			fsa.generateFile(c.fullyQualifiedName.toString("/") + ".java", c.compile)
		}
	}
	
	def generatePortClass(IFileSystemAccess access) { 
		access.generateFile("utils/Port.java", compilePort());
	}
	
	def String compilePort() '''
		package utils;
		
		import java.util.LinkedList;
		
		public class Port<T> {
		
			private final LinkedList<T> buffer;
		
			public Port() {
				buffer = new LinkedList<>();
			}
		
			public synchronized void push(T e) {
				buffer.add(e);
			}
		
			public synchronized T pop() {
				if (buffer.size() == 0) {
					return null;
				}
				
				T e = buffer.getFirst();
				buffer.removeFirst();
				return e;
			}

		}
	'''
	
	
	def String compile(Component c) '''
		package «c.model.fullyQualifiedName.toString(".")»;
		
		import utils.*;
		
		public class «c.name» {
			
			«FOR e : c.elements»
				«switch e {
					Port : e.compileDecl
					Embedding : e.compileDecl
				}»
			«ENDFOR»
			«c.parameters.compileDecl»
			
			«IF c.parameters.size > 0 »
			/**
			 * Constructor for embedding this component.
			 */
			public «c.name» («c.parameters.compileDeclArgument») {
				«c.parameters.compileInit»
				
				«FOR e : c.elements»
					«switch e {
						Port : e.compileInstantiation
						Embedding : e.compileInstantiation
					}»
				«ENDFOR»
			}
			«ENDIF»
			
			/**
			 * Default constructor.
			 */
			public «c.name» () {
				«c.parameters.compileInitDefault»
				
				«FOR e : c.elements»
					«switch e {
						Port : e.compileInstantiation
						Embedding : e.compileInstantiation
					}»
				«ENDFOR»
			}
		}
	'''
	
	def compileInstantiation(Embedding e) '''
		«if(e.eIsSet(e.eClass.getEStructuralFeature("cardinality"))) {
			'''
			«e.name» = new «e.component.name»[«e.cardinality.compile»];
			for(int i = 0; i < «e.cardinality.compile»; ++ i)
				«e.name»[i] = new «e.component.name»(«FOR v : e.parameterValues SEPARATOR ", "»«v.compile»«ENDFOR»);
			'''
		} else {
			'''
			«e.name» = new «e.component.name»(«FOR v : e.parameterValues SEPARATOR ", "»«v.compile»«ENDFOR»);
			'''
		}»
	'''
	def compile(Value v) {
		if (v instanceof IntegerLiteral) {
			var IntegerLiteral il = v as IntegerLiteral
			'''«il.value»'''
		} else if (v instanceof ParameterRef) {
			var ParameterRef pr = v as ParameterRef
			'''«pr.parameter.name»'''
		}
	}


	def String compileDecl(Embedding e) '''
		«if(e.eIsSet(e.eClass.getEStructuralFeature("cardinality"))) {
			'''private final «e.component.name»[] «e.name»;'''
		} else {
			'''private final «e.component.name» «e.name»;'''
		}»
	'''

	
	def compileDecl(EList<Parameter> list) { 
		'''«FOR p : list BEFORE "private final int " SEPARATOR "\nprivate final int "»«p.name»;«ENDFOR»'''
	}

	def compileInitDefault(EList<Parameter> list) {
		'''«FOR p : list BEFORE "this." SEPARATOR "\nthis."»«p.name» = «p.value»;«ENDFOR»'''
	}

	def compileInit(EList<Parameter> list) { 
		'''«FOR p : list BEFORE "this." SEPARATOR "\nthis."»«p.name» = «p.name»;«ENDFOR»'''
	}

	def compileDeclArgument(EList<Parameter> list) { 
		'''«FOR p : list BEFORE "int " SEPARATOR ", int "»«p.name»«ENDFOR»'''
	}
	
	def compileInstantiation(Port p) '''
		«if(p.eIsSet(p.eClass.getEStructuralFeature("cardinality"))) {
			'''
			«p.identifier» = new Port[«p.cardinality.compile»];
			for(int i = 0; i < «p.cardinality.compile»; ++ i)
				«p.identifier»[i] = new Port<«p.typeRef.typeName»>();
			'''
		} else {
			'''
			«p.identifier» = new Port<«p.typeRef.typeName»>();
			'''
		}»
	'''
	
	def Model model(Component c) {
		EcoreUtil2::getContainerOfType(c, typeof(Model))
	}
	
	def String compileDecl(Port p) '''
		«if(p.eIsSet(p.eClass.getEStructuralFeature("cardinality"))) {
			'''public final Port<«p.typeRef.typeName»>[] «p.identifier»;'''
		} else {
			'''public final Port<«p.typeRef.typeName»> «p.identifier»;'''
		}»
	'''	
	
	def String identifier(Callable c) {
		c.name
	}
	
	def String typeName(TypeRef ref) {
		switch ref {
			PrimitiveTypeRef : ref.type.primitiveTypeName
			default: "Object"
		}
	}

	def String primitiveTypeName(PrimitiveTypes t) {
		switch t {
			case PrimitiveTypes::BOOLEAN : "Boolean"
			case PrimitiveTypes::INTEGER : "Integer"
			case PrimitiveTypes::REAL : "Float"
		}
	}
}
