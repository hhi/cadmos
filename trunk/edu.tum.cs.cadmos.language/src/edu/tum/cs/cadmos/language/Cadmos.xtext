grammar edu.tum.cs.cadmos.language.Cadmos with org.eclipse.xtext.common.Terminals

generate cadmos "http://www.tum.edu/cs/cadmos/language/Cadmos"

/* MODEL ELEMENTS */
Model:
	('package' name=QualifiedName)?
	imports+=Import*
	elements+=ModelElement*;

Import:
	'import' importedNamespace=QualifiedNameWithWildcard;

ModelElement:
	Component;

Component:
	'component' name=ID
	('(' (parameters+=Parameter (',' parameters+=Parameter)*)? ')')?
	'{' (elements+=ComponentElement)* '}';

Parameter:
	name=ID '=' value=INT;

ComponentElement:
	Port
	| Embedding
	| Variable
	| Channel
	| Case
	| Expression;

enum PortDirection:
	Inbound='in'
	| Outbound='out';

Port:
	direction=PortDirection typeRef=TypeRef? name=ID ('[' cardinality=Value ']')? ('rate' rate=Value)?;

Embedding:
	'embed' component=[Component]
	('(' (parameterValues+=Value (',' parameterValues+=Value)*)? ')')?
	name=ID ('[' cardinality=Value ']')?;

Channel:
	'channel' source=PortRef '->' destination=PortRef;

PortRef:
	(embedding=[Embedding] ('[' embeddingIndex=ID ']')? '.')? port=[Port] ('[' portIndex=ID ']')?;

Value:
	IntegerLiteral
	| ParameterRef;

ParameterRef:
	parameter=[Parameter];

Variable:
	'var' typeRef=TypeRef name=ID ('=' initializer=Expression)?;

Case:
	'case' guard=Expression '{' (subcases+=Case | actions+=Expression)* '}';

/* EXPRESSIONS */
Expression returns Expression:
	Assignment;

Assignment returns Expression:
	OrExpression (=> ({BinaryExpression.left=current} op='=') right=OrExpression)*;

OrExpression returns Expression:
	AndExpression (=> ({BinaryExpression.left=current} op='||') right=AndExpression)*;

AndExpression returns Expression:
	EqualityExpression (=> ({BinaryExpression.left=current} op='&&') right=EqualityExpression)*;

EqualityExpression returns Expression:
	RelationalExpression (=> ({BinaryExpression.left=current} op=('==' | '!=')) right=RelationalExpression)*;

RelationalExpression returns Expression:
	AdditiveExpression (=> ({BinaryExpression.left=current} op=('>=' | '<=' | '>' | '<')) right=AdditiveExpression)*;

AdditiveExpression returns Expression:
	MultiplicativeExpression (=> ({BinaryExpression.left=current} op=('+' | '-')) right=MultiplicativeExpression)*;

MultiplicativeExpression returns Expression:
	UnaryExpression (=> ({BinaryExpression.left=current} op=('*' | '**' | '/' | '%')) right=UnaryExpression)*;

UnaryExpression returns Expression:
	{UnaryExpression} op=('!' | '+' | '-') operand=PrimaryExpression
	| PrimaryExpression;

PrimaryExpression returns Expression:
	Call
	| ParenthesizedExpression
	| Literal;

Call returns Expression:
	Segment (=> ({BinaryExpression.left=current} op='.') right=Segment)*;

Segment returns Expression:
	CallableSegment
	| ClosureSegment
	| NativeFunctionSegment;

Callable:
	Port
	| Variable
	| ClosureParameter
	| Parameter;

CallableSegment returns Expression:
	{CallableSegment} callable=[Callable] ('[' index+=Expression ']')?;

enum ClosureOperators:
	ForEach='forEach' | Exists='exists' | All='all' | Select='select' | Collect='collect';

ClosureSegment returns Expression:
	{ClosureSegment} operator=ClosureOperators
	'(' (parameters+=ClosureParameter (',' parameters+=ClosureParameter)* '|')? expression=Expression ')';

ClosureParameter:
	name=ID;

ParenthesizedExpression returns Expression:
	'(' Expression ')';

enum NativeFunctionNames:
	TimedAccess='at';

NativeFunctionSegment returns Expression:
	{NativeFunctionSegment} name=NativeFunctionNames
	'(' parameterValues+=Expression (',' parameterValues+=Expression)* ')';

Literal returns Expression:
	BooleanLiteral | IntegerLiteral | RealLiteral;

BooleanLiteral returns Expression:
	{BooleanLiteral} ('false' | isTrue?='true');

IntegerLiteral returns Expression:
	{IntegerLiteral} value=INT;

RealLiteral returns Expression:
	{RealLiteral} value=REAL;

/* TYPE SYSTEM */
TypeRef:
	PrimitiveTypeRef;

PrimitiveTypeRef:
	type=PrimitiveTypes;

enum PrimitiveTypes:
	Boolean='boolean'
	| Integer='int'
	| Real='real';

/* TERMINALS AND NAMES */
QualifiedName:
	ID ('.' ID)*;

QualifiedNameWithWildcard:
	QualifiedName '.*'?;

terminal REAL:
	('0'..'9')* '.' ('0'..'9')+ (('e' | 'E') ('+' | '-')? ('0'..'9')+)?;
