/*
 * generated by Xtext
 */
package edu.tum.cs.cadmos.language.scoping;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.eclipse.emf.ecore.EReference;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.Scopes;
import org.eclipse.xtext.scoping.impl.AbstractDeclarativeScopeProvider;

import edu.tum.cs.cadmos.common.ListUtils;
import edu.tum.cs.cadmos.language.ModelUtils;
import edu.tum.cs.cadmos.language.cadmos.Callable;
import edu.tum.cs.cadmos.language.cadmos.CallableSegment;
import edu.tum.cs.cadmos.language.cadmos.ClosureParameter;
import edu.tum.cs.cadmos.language.cadmos.ClosureSegment;
import edu.tum.cs.cadmos.language.cadmos.Component;
import edu.tum.cs.cadmos.language.cadmos.Embedding;
import edu.tum.cs.cadmos.language.cadmos.ParameterAssignment;
import edu.tum.cs.cadmos.language.cadmos.Port;
import edu.tum.cs.cadmos.language.cadmos.PortRef;

/**
 * This class contains custom scoping description.
 * 
 * see : http://www.eclipse.org/Xtext/documentation/latest/xtext.html#scoping on
 * how and when to use it
 * 
 */
public class CadmosScopeProvider extends AbstractDeclarativeScopeProvider {

	public IScope scope_PortRef_port(PortRef portRef, EReference ref) {
		final Embedding embedding = portRef.getEmbedding();
		final Component component;
		if (embedding == null) {
			component = EcoreUtil2.getContainerOfType(portRef, Component.class);
		} else {
			component = embedding.getComponent();
		}
		if (component == null) {
			return IScope.NULLSCOPE;
		}
		final List<Port> ports = ListUtils.filter(component.getElements(),
				Port.class);
		return Scopes.scopeFor(ports);
	}

	public IScope scope_ParameterAssignment_left(
			ParameterAssignment assignment, EReference ref) {
		final Embedding embedding = EcoreUtil2.getContainerOfType(assignment,
				Embedding.class);
		if (embedding == null) {
			return IScope.NULLSCOPE;
		}
		final Component component = embedding.getComponent();
		if (component == null) {
			return IScope.NULLSCOPE;
		}
		return Scopes.scopeFor(component.getParameters());
	}

	public IScope scope_CallableSegment_callable(CallableSegment segment,
			EReference ref) {
		final List<Callable> callables = new ArrayList<>();
		// Add all callables of container component (parameters, ports,
		// variables).
		final Component component = EcoreUtil2.getContainerOfType(segment,
				Component.class);
		callables.addAll(component.getParameters());
		callables.addAll(ModelUtils.getPorts(component));
		callables.addAll(ModelUtils.getVariables(component));
		// Add all callable closure parameters.
		// "Inner names" remain visible if equal "outer names" are present in
		// scope.
		final Map<String, ClosureParameter> closureParameters = new HashMap<>();
		ClosureSegment parentSegment = EcoreUtil2.getContainerOfType(
				segment.eContainer(), ClosureSegment.class);
		while (parentSegment != null) {
			for (final ClosureParameter p : parentSegment.getParameters()) {
				if (!closureParameters.containsKey(p.getName())) {
					closureParameters.put(p.getName(), p);
				}
			}
			parentSegment = EcoreUtil2.getContainerOfType(
					parentSegment.eContainer(), ClosureSegment.class);
		}
		callables.addAll(closureParameters.values());
		System.out.println(callables);
		return Scopes.scopeFor(callables);
	}
}
