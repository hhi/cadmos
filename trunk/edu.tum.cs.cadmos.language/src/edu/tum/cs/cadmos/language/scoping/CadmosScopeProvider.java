/*
 * generated by Xtext
 */
package edu.tum.cs.cadmos.language.scoping;

import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.Scopes;
import org.eclipse.xtext.scoping.impl.AbstractDeclarativeScopeProvider;

import edu.tum.cs.cadmos.common.ListUtils;
import edu.tum.cs.cadmos.language.ModelUtils;
import edu.tum.cs.cadmos.language.cadmos.Component;
import edu.tum.cs.cadmos.language.cadmos.Embedding;
import edu.tum.cs.cadmos.language.cadmos.EnumDecl;
import edu.tum.cs.cadmos.language.cadmos.EnumElementCall;
import edu.tum.cs.cadmos.language.cadmos.LocalCall;
import edu.tum.cs.cadmos.language.cadmos.Port;
import edu.tum.cs.cadmos.language.cadmos.PortRef;

/**
 * This class contains custom scoping description.
 * 
 * see : http://www.eclipse.org/Xtext/documentation/latest/xtext.html#scoping on
 * how and when to use it
 * 
 */
public class CadmosScopeProvider extends AbstractDeclarativeScopeProvider {

	public IScope scope_PortRef_port(PortRef portRef, EReference ref) {
		final Embedding embedding = portRef.getEmbedding();
		final Component component;
		if (embedding == null) {
			component = EcoreUtil2.getContainerOfType(portRef, Component.class);
		} else {
			component = embedding.getComponent();
		}
		if (component == null) {
			return IScope.NULLSCOPE;
		}
		final List<Port> ports = ListUtils.filter(component.getElements(),
				Port.class);
		return Scopes.scopeFor(ports);
	}

	public IScope scope_EnumElementCall_element(EnumElementCall call,
			EReference ref) {
		final EnumDecl enumDecl = call.getEnumDecl();
		if (enumDecl == null) {
			return IScope.NULLSCOPE;
		}
		return Scopes.scopeFor(enumDecl.getElements());
	}

	public IScope scope_LocalCall_local(LocalCall call, EReference ref) {
		final Map<String, EObject> locals = new HashMap<>();
		// Add all callable closure parameters declared by parent calls.
		// "Inner names" remain visible if equal "outer names" are present in
		// scope (i.e. "outer names" are shadowed by "inner names").
		LocalCall parentCall = EcoreUtil2.getContainerOfType(call.eContainer(),
				LocalCall.class);
		while (parentCall != null) {
			// First (== inner) declarations of names remains visible.
			extendScopeAndKeepExisting(locals,
					parentCall.getClosureParameters());
			parentCall = EcoreUtil2.getContainerOfType(parentCall.eContainer(),
					LocalCall.class);
		}
		// Add all local callables of container component (parameters, ports,
		// variables).
		final Component component = EcoreUtil2.getContainerOfType(call,
				Component.class);
		extendScopeAndKeepExisting(locals, ModelUtils.getVariables(component));
		extendScopeAndKeepExisting(locals, ModelUtils.getPorts(component));
		extendScopeAndKeepExisting(locals, component.getParameters());
		return Scopes.scopeFor(locals.values());
	}

	private static void extendScopeAndKeepExisting(
			Map<String, EObject> existingScope,
			Collection<? extends EObject> newItems) {
		for (final EObject item : newItems) {
			final String name = ModelUtils.getEObjectName(item, false);
			if (!existingScope.containsKey(name)) {
				existingScope.put(name, item);
			}
		}
	}
}
